# Java Concurrency In Practice

## 운영체제가 여러 프로그램을 동시에 수행해야 하는 이유

**자원 활용:** 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하는 것이 효율적이다.  
**공정성:** 하나의 프로그램이 끝난 후에야 다른 프로그램이 실행 되는 것보다는 더 작은 단위로 컴퓨터를 공유하는 것이 더 효율적이다.  
**편의성:** 하나의 프로그램이 여러 작업을 전부 처리하는 것보다 여러 프로그램들이 각기 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율하는 프로그램이 존재하는게 효율적이다.  
**순차적으로 할일과 비동기적으로 할 일 간에 적절히 균형을 찾아야 한다.**  
 스레드는 위와 같은 필요성 때문에 고안되었다. 스레드로 인해 한 프로세스 안에 여러 개의 context flow가 공존할 수 있다. 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 갖는다.
스레드는 자신이 포함된 메모리 주소 공간을 공유하기 때문에 한 프로세스내의 모드 스레드는 같은 변수에 접근하고, 같은 힙에 객체를 할당한다.

## 스레드 사용의 위험성

### 안정성 위해 요소
```Java
@NotThreadSafe
public class UnsafeSequence {
	private int value;
	
	public int getNext() {
		return value++;
	}
}
```
위의 코드는 스레드가 여러개 일때 제대로 동작하지 않는다. `race condition`이 존재하기 때문이다. 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도
있다. 데이터 공유가 쉽다는 이점이 존재하기도 하지만, 데이터가 예측 못하는 시점에서 변경될 수 있으므로 위험 요소이기도 하다.

```Java
@ThreadSafe
public class Sequence {
	@GuardedBy("this") private int value;
	
	public synchronized int getNext() {
		return value++;
	}
}
```
위와 같이 동기화된 메소드로 만들면 문제가 해결된다.

### 활동성 위험
안전성이 "잘못된 일이 생기지 않는다"는 것을 뜻하는 반면, 활동성은 "원하는 일이 결국 일어난다"는 보완적인 목표에 대한 것이다. 스레드를 잘못 사용 한다면 어떤 작업이 전현 진전되지 못하는 
상태에 빠질 수 있다.

### 성능 위험
잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있다. 하지만 스레드가 많은 프로그램에서는 컨텍스트 스위칭이 더 빈번하고, 그 때문에 상당한 부담이 생긴다.
즉, 실행중인 컨텍스트를 저장하고 다시 읽어들여야 하며, 메모리의 locality가 손실되고, CPU시간을 스케쥴링 하는데 소모해야 한다. 또 스레드가 데이터를 공유할 때는 동기화 수단도 사용해야 한다.
이런 동기화는 컴파일러 최적화르 방해하고, 메모리 캐시를 지우거나 무효화하기도 한다. 그 밖에 공유 메모리 버스에 동기화 관련 트래픽을 유발한다.
이런 모든 요인은 성능측면에서 추가적인 손실을 유발한다.

## 스레드는 어디에나
프로그램이 직접 스레드를 생성하지 않더라도 프로그램이 사용하는 프레임워크에서 스레드를 생성할 수도 있다. 따라서 그런 스레드에서 호출되는 코드는 스레드에 대해 안전해야 한다.
프레임워크 때문에 프로그램이 병렬로 실행된는 경우가 생기면 병렬로 실행된다는 사실을 프레임워크 뿐만 아니라 프로그램에서도 인식하고 적절히 대응해야 한다. 프레임워크에 의해
호출되는 컴포넌트만 스레드에 안전해야 하는 것이 아니라, 해당 컴포넌트가 실행되는 과정에서 접근하는 코드 경로에 포함된 컴포넌트는 모두 마찬가지이다. **이처럼 스레드 안전성에는 전염성이 있다.**  
  
**`Timer`:** `Timer`는 추후에 한 번 혹은 주기적으로 실행될 작업을 스케줄하기 위한 편의 수단이다. `Timer`를 사용하면 `TimerTask`에 지정된 작업이 프로그램이 아닌 `Tiemr`가 관리하는
스레드에서 실행되기 때문에 순차적인 프로그램을 복잡하게 만들 수도 있다. 만약 기본 프로그램의 스레드가 사용하는 데이터에 `TimerTask`의 작업이 접근하면, `TimerTask`뿐 아니라 해당 데이터에 
접근하는 다른 모든 클래스도 스레드에 안전하게 만들어야 한다. 이런 경우에 가장 쉬운 방법은 `TimerTask`가 접근하는 객체 자체를 스레드에 안전하게 만드는 것이다. 즉 공유된 데이터 객체 내부에
스레드 안전성을 캡슐화 하는 것이다.
